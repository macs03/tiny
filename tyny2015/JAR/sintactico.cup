package compilador;

import java_cup.runtime.*;
import ast.*;

action code {:
	private boolean modoDepuracion=true;
	private NodoBase ast=null;
	private int lineanum=0;
	
	//Debe ser llamada solo despues de un parse(), en caso contrario retornara null siempre;
	public NodoBase getASTroot(){
		return ast;
	}
:}

/* Simbolos Terminales */

terminal IF;
terminal THEN;
terminal ELSE;
terminal END;
terminal REPEAT;
terminal UNTIL;
terminal READ;
terminal WRITE;
terminal String ID;
terminal Integer NUM;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal MT;
terminal MEQT;
terminal LEQT;
terminal DIF;
terminal AND;
terminal OR;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal OVER;
terminal LPAREN;
terminal RPAREN;
terminal SEMI;
terminal FOR;
terminal INT;
terminal BOOLEAN;
terminal COMA;
terminal RETURN;
terminal BEGIN;
terminal VOID;
terminal LCORCHETE;
terminal RCORCHETE;



/* Simbolos No Terminales */
non terminal program;
non terminal NodoBase stmt_seq;
non terminal NodoBase stmt;
non terminal NodoBase if_stmt;
non terminal NodoBase repeat_stmt;
non terminal NodoBase assign_stmt;
non terminal NodoBase read_stmt;
non terminal NodoBase write_stmt;
non terminal NodoBase exp;
non terminal NodoBase simple_exp;
non terminal NodoBase term;
non terminal NodoBase factor;
non terminal NodoBase for_stmt;
non terminal NodoBase parametro_seq;
non terminal NodoBase parametro_seq2;
non terminal NodoBase parametro;
non terminal NodoBase llamar_functionR;
non terminal NodoBase llamar_function;
non terminal NodoBase vector;
non terminal NodoBase function_seq;
non terminal NodoBase cp;
non terminal NodoBase function;
non terminal NodoBase tipo;
non terminal NodoBase bloque;
non terminal NodoBase return;
non terminal NodoBase operacion;
non terminal NodoBase exp_p;
non terminal NodoBase procedure;
non terminal NodoBase fun_pro;
non terminal NodoBase asig;
non terminal NodoBase paso;

non terminal NodoBase declarar_stmt;
non terminal NodoBase declaraciones;
non terminal NodoBase declaracion; 


/* Precedencia de operadores */
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;


/* REGLAS GRAMATICALES */
program     ::= function_seq cp {: if (modoDepuracion)
                                    System.out.println("\t regla: program ::= funtion_seq cp ");    
                                :}
                |cp
                | error {: if(modoDepuracion){ System.out.println("\t regla programa invalida"); 
			       // System.out.println("Ocurrio error en cup # 0004");
		                RESULT=null;
                                System.exit(0);
                         }
	            :}	
		;
function_seq ::= function_seq fun_pro {: if (modoDepuracion)
                                                System.out.println("\t regla: function_seq ::= funtion_seq fun_pro ");    
                                       :} 
                | fun_pro {: if (modoDepuracion)
                                 System.out.println("\t regla: function_seq ::= fun_pro ");    
                          :}
                ;

fun_pro ::= function {: if (modoDepuracion)
                              System.out.println("\t regla: fun_pro ::= function ");    
                      :}
            | procedure {: if (modoDepuracion)
                              System.out.println("\t regla: fun_pro ::= procedure ");    
                         :}
                ;

function ::= tipo ID LPAREN parametro_seq RPAREN bloque return END
             	
                ;

procedure ::= VOID ID LPAREN parametro_seq RPAREN cp

           
                ;

cp ::= bloque END
                ;

bloque ::= BEGIN stmt_seq 
                ;

stmt_seq    ::= stmt_seq stmt {: if (modoDepuracion)
                                        System.out.println("\t regla: stmt_seq ::= stmt_seq stmt ");    
                                :}	
               | stmt {: if (modoDepuracion)
                                        System.out.println("\t regla: stmt_seq ::= stmt ");    
                            :}
               ;

stmt        ::= if_stmt {: if (modoDepuracion)
                                        System.out.println("\t regla: stmt ::= if_stmt ");    
                         :}	
            | repeat_stmt {: if (modoDepuracion)
                                        System.out.println("\t regla: stmt ::= stmt_repeat ");    
                          :}	
            | assign_stmt {: if (modoDepuracion)
                                        System.out.println("\t regla: stmt ::= stmt_assign ");    
                          :}	
            | read_stmt	{: if (modoDepuracion)
                                        System.out.println("\t regla: stmt ::= read_stmt ");    
                          :}
            | write_stmt {: if (modoDepuracion)
                                        System.out.println("\t regla: stmt ::= write_stmt");    
                          :}	
            | for_stmt {: if (modoDepuracion)
                                        System.out.println("\t regla: stmt ::= for_stmt ");    
                          :}

            | declarar_stmt {: if (modoDepuracion)
                                        System.out.println("\t regla: stmt ::= declarar_stmt ");    
                          :}

            | llamar_function {: if (modoDepuracion)
                                        System.out.println("\t regla: stmt ::= llamar_function");    
                          :}
            	
            ;

if_stmt     ::= IF operacion:ex THEN stmt_seq:pthen END	
		| IF operacion:ex THEN stmt_seq:pthen ELSE stmt_seq:pelse END	
                
               
		;


repeat_stmt ::= REPEAT stmt_seq:cuerpo UNTIL operacion:prueba

                	

		;

assign_stmt ::= ID:variable ASSIGN operacion:ex SEMI
                 | vector ASSIGN exp SEMI
                 
                 	
                 
		;

read_stmt   ::= READ ID:variable SEMI

                	
		;

write_stmt  ::= WRITE operacion:ex SEMI

            
		;

exp         ::= simple_exp:exI LT simple_exp:exD	
		| simple_exp:exI EQ simple_exp:exD	
		| simple_exp:ex	
                | simple_exp MT simple_exp

                | simple_exp MEQT simple_exp

                | simple_exp LEQT simple_exp
		
                | simple_exp DIF simple_exp
                
                
                
               
                ;

simple_exp  ::= simple_exp:exI PLUS term:exD	
		| simple_exp:exI MINUS term:exD	
		| term:ex

                
		;

term        ::= term:exI TIMES factor:exD	
		| term:exI OVER factor:exD	
		| factor:ex
               
		;

factor      ::= LPAREN operacion:ex RPAREN	
		| NUM:valor	
		| ID:variable	
                | vector
                | llamar_functionR
              
		;
for_stmt    ::= FOR LPAREN asig SEMI operacion SEMI paso RPAREN bloque END
                
             

                ;

asig ::= ID ASSIGN NUM
           	

                ;

paso ::= ID ASSIGN simple_exp

                ;


declarar_stmt   ::= tipo declaraciones SEMI
                                
                ;

declaraciones   ::= declaraciones COMA declaracion | declaracion 

                ;

declaracion     ::= ID | vector
                ;





llamar_functionR ::= ID LPAREN parametro_seq2 RPAREN 
                  

                ;

llamar_function ::= ID LPAREN parametro_seq2 RPAREN SEMI 
               

                ;

parametro_seq ::= parametro_seq COMA parametro | parametro |
               

                ;

parametro ::= tipo factor 
             	
                ;

parametro_seq2 ::= parametro_seq2 COMA factor | factor | 
                ;

vector ::= ID LCORCHETE operacion RCORCHETE

                ;


operacion ::= operacion OR exp_p | exp_p
                	

                ;

exp_p ::= exp_p AND exp | exp
                        
               ;

return ::= RETURN operacion SEMI

    
            ;

tipo ::= INT | BOOLEAN
             
            ;